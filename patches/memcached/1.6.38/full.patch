--- memcached.c.orig	2025-04-24 14:38:45.912822441 -0400
+++ memcached.c	2025-04-24 14:54:54.719835045 -0400
@@ -167,6 +167,87 @@
 }
 
 /*
+ * Docker-friendly environment-based configuration injector.
+ *
+ * This function scans environment variables prefixed with "MC_" and
+ * translates them into command-line arguments compatible with memcached's CLI.
+ * It supports both flag-style (e.g. -v, -S) and key-value style (e.g. -m 64, -o ssl_key=...).
+ *
+ * This enables runtime configuration purely via environment variables,
+ * making it ideal for containerized deployments where argv may be fixed.
+ *
+ * Extended options (like TLS and SASL configuration) are packed into the -o flag.
+ * Verbosity levels (e.g., -vvv) are derived from MC_VERBOSE=n.
+ *
+ * This system is ignored if CLI flags are already passed directly,
+ * but provides sane defaults for lightweight containers.
+ */
+struct envopt {
+    const char *env;
+    const char *flag;
+    int expects_value;
+};
+
+static const struct envopt envopts[] = {
+    { "MC_MAX_MEMORY",       "-m", 1 },
+    { "MC_CONNECTIONS",      "-c", 1 },
+    { "MC_THREADS",          "-t", 1 },
+    { "MC_PROTOCOL",         "-B", 1 },
+    { "MC_REQS_PER_EVENT",   "-R", 1 },
+    { "MC_FACTOR",           "-f", 1 },
+    { "MC_MAX_ITEM_SIZE",    "-I", 1 },
+    { "MC_MIN_ITEM_SIZE",    "-n", 1 },
+
+    // Flags with no value
+    { "MC_SASL",             "-S", 0 },
+    { "MC_ALLOW_SHUTDOWN",   "-A", 0 },
+    { "MC_DISABLE_CAS",      "-C", 0 },
+    { "MC_LOCK_PAGES",       "-k", 0 },
+    { "MC_NO_SLAB_REASSIGN", "-r", 0 },
+
+    // Special: verbose (-v, -vv, etc.)
+    { "MC_VERBOSE",          "-v", 1 },
+
+    // TLS
+    { "MC_TLS",              "-Z", 0 },
+
+    // Extended opts
+    { "MC_EXTENDED_OPTS",    "-o", 1 },
+
+    { NULL, NULL, 0 }
+};
+
+void inject_env_args(int *argc, char ***argv) {
+    int extra = 0;
+    char **new_argv = malloc(sizeof(char*) * (*argc + 64)); // generous buffer
+    new_argv[extra++] = (*argv)[0]; // program name
+
+    for (int i = 0; envopts[i].env; i++) {
+        const char *val = getenv(envopts[i].env);
+        if (!val) continue;
+
+        if (strcmp(envopts[i].flag, "-v") == 0) {
+            int level = atoi(val);
+            for (int v = 0; v < level && v < 10; v++)
+                new_argv[extra++] = strdup("-v");
+            continue;
+        }
+
+        new_argv[extra++] = strdup(envopts[i].flag);
+        if (envopts[i].expects_value)
+            new_argv[extra++] = strdup(val);
+    }
+
+    for (int i = 1; i < *argc; i++) {
+        new_argv[extra++] = (*argv)[i];
+    }
+
+    new_argv[extra] = NULL;
+    *argv = new_argv;
+    *argc = extra;
+}
+
+/*
  * given time value that's either unix time or delta from current unix time, return
  * unix time. Use the fact that delta can't exceed one month (and real time value can't
  * be that low).
@@ -4677,6 +4758,12 @@
 }
 
 int main (int argc, char **argv) {
+    if (argc > 1) {
+        fprintf(stderr, "This container does not accept command-line arguments.\n"
+                        "Please configure via environment variables prefixed with MC_.\n");
+        return 1;
+    }
+    inject_env_args(&argc, &argv);
     int c;
     bool lock_memory = false;
     bool do_daemonize = false;
